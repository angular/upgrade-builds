{"version":3,"file":"angular1.js","sourceRoot":"","sources":["../../../../../../packages/upgrade/static/src/common/angular1.ts"],"names":[],"mappings":";;;;;;;AAuNA;IACE,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;CAClD;AAGD,IAAI,OAAO,GAQF;IACP,SAAS,EAAE,IAAI;IACf,MAAM,EAAE,IAAI;IACZ,OAAO,EAAE,IAAI;IACb,OAAO,EAAE,SAAS;IAClB,eAAe,EAAE,IAAI;IACrB,cAAc,EAAE,IAAI;CACrB,CAAC;AAEF,IAAI,CAAC;IACH,EAAE,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACrC,OAAO,GAAS,MAAO,CAAC,OAAO,CAAC;KACjC;CACF;AAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;;CAEZ;;;;AAKD,MAAM,wBAAwB,EAAO;IACnC,kBAAkB,CAAC,EAAE,CAAC,CAAC;CACxB;;;;AAKD,MAAM;IACJ,MAAM,CAAC,kBAAkB,EAAE,CAAC;CAC7B;;;;;;;;AASD,MAAM,6BAA6B,EAAO;IACxC,OAAO,GAAG,EAAE,CAAC;IACb,OAAO,GAAG,EAAE,IAAI,EAAE,CAAC,OAAO,CAAC;CAC5B;;;;;;AAOD,MAAM;IACJ,MAAM,CAAC,OAAO,CAAC;CAChB;AAED,MAAM,CAAC,MAAM,SAAS,GAClB,CAAC,CAAU,EAAE,OAAiC,EAAE,MAAgC,EAAE,EAAE,CAChF,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;AAE9C,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,MAAc,EAAE,YAAuB,EAAE,EAAE,CAC9D,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AAEzC,MAAM,CAAC,MAAM,OAAO,GAAG,CAAC,CAAmB,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAEnE,MAAM,CAAC,MAAM,eAAe,GAAG,GAAG,EAAE,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;AAE/D,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,CAAU,EAAE,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;AAExE,MAAM,CAAC,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport type Ng1Token = string;\n\nexport type Ng1Expression = string | Function;\n\nexport interface IAnnotatedFunction extends Function { $inject?: Ng1Token[]; }\n\nexport type IInjectable = (Ng1Token | Function)[] | IAnnotatedFunction;\n\nexport type SingleOrListOrMap<T> = T | T[] | {[key: string]: T};\n\nexport interface IModule {\n  name: string;\n  requires: (string|IInjectable)[];\n  config(fn: IInjectable): IModule;\n  directive(selector: string, factory: IInjectable): IModule;\n  component(selector: string, component: IComponent): IModule;\n  controller(name: string, type: IInjectable): IModule;\n  factory(key: Ng1Token, factoryFn: IInjectable): IModule;\n  value(key: Ng1Token, value: any): IModule;\n  constant(token: Ng1Token, value: any): IModule;\n  run(a: IInjectable): IModule;\n}\nexport interface ICompileService {\n  (element: Element|NodeList|Node[]|string, transclude?: Function): ILinkFn;\n}\nexport interface ILinkFn {\n  (scope: IScope, cloneAttachFn?: ICloneAttachFunction, options?: ILinkFnOptions): IAugmentedJQuery;\n  $$slots?: {[slotName: string]: ILinkFn};\n}\nexport interface ILinkFnOptions {\n  parentBoundTranscludeFn?: Function;\n  transcludeControllers?: {[key: string]: any};\n  futureParentElement?: Node;\n}\nexport interface IRootScopeService {\n  $new(isolate?: boolean): IScope;\n  $id: string;\n  $parent: IScope;\n  $root: IScope;\n  $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;\n  $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\n  $destroy(): any;\n  $apply(exp?: Ng1Expression): any;\n  $digest(): any;\n  $evalAsync(exp: Ng1Expression, locals?: any): void;\n  $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;\n  $$childTail: IScope;\n  $$childHead: IScope;\n  $$nextSibling: IScope;\n  [key: string]: any;\n}\nexport interface IScope extends IRootScopeService {}\n\nexport interface IAngularBootstrapConfig { strictDi?: boolean; }\nexport interface IDirective {\n  compile?: IDirectiveCompileFn;\n  controller?: IController;\n  controllerAs?: string;\n  bindToController?: boolean|{[key: string]: string};\n  link?: IDirectiveLinkFn|IDirectivePrePost;\n  name?: string;\n  priority?: number;\n  replace?: boolean;\n  require?: DirectiveRequireProperty;\n  restrict?: string;\n  scope?: boolean|{[key: string]: string};\n  template?: string|Function;\n  templateUrl?: string|Function;\n  templateNamespace?: string;\n  terminal?: boolean;\n  transclude?: DirectiveTranscludeProperty;\n}\nexport type DirectiveRequireProperty = SingleOrListOrMap<string>;\nexport type DirectiveTranscludeProperty = boolean | 'element' | {[key: string]: string};\nexport interface IDirectiveCompileFn {\n  (templateElement: IAugmentedJQuery, templateAttributes: IAttributes,\n   transclude: ITranscludeFunction): IDirectivePrePost;\n}\nexport interface IDirectivePrePost {\n  pre?: IDirectiveLinkFn;\n  post?: IDirectiveLinkFn;\n}\nexport interface IDirectiveLinkFn {\n  (scope: IScope, instanceElement: IAugmentedJQuery, instanceAttributes: IAttributes,\n   controller: any, transclude: ITranscludeFunction): void;\n}\nexport interface IComponent {\n  bindings?: {[key: string]: string};\n  controller?: string|IInjectable;\n  controllerAs?: string;\n  require?: DirectiveRequireProperty;\n  template?: string|Function;\n  templateUrl?: string|Function;\n  transclude?: DirectiveTranscludeProperty;\n}\nexport interface IAttributes {\n  $observe(attr: string, fn: (v: string) => void): void;\n  [key: string]: any;\n}\nexport interface ITranscludeFunction {\n  // If the scope is provided, then the cloneAttachFn must be as well.\n  (scope: IScope, cloneAttachFn: ICloneAttachFunction): IAugmentedJQuery;\n  // If one argument is provided, then it's assumed to be the cloneAttachFn.\n  (cloneAttachFn?: ICloneAttachFunction): IAugmentedJQuery;\n}\nexport interface ICloneAttachFunction {\n  // Let's hint but not force cloneAttachFn's signature\n  (clonedElement?: IAugmentedJQuery, scope?: IScope): any;\n}\nexport type IAugmentedJQuery = Node[] & {\n  on?: (name: string, fn: () => void) => void;\n  data?: (name: string, value?: any) => any;\n  text?: () => string;\n  inheritedData?: (name: string, value?: any) => any;\n  contents?: () => IAugmentedJQuery;\n  parent?: () => IAugmentedJQuery;\n  empty?: () => void;\n  append?: (content: IAugmentedJQuery | string) => IAugmentedJQuery;\n  controller?: (name: string) => any;\n  isolateScope?: () => IScope;\n  injector?: () => IInjectorService;\n  remove?: () => void;\n  removeData?: () => void;\n};\nexport interface IProvider { $get: IInjectable; }\nexport interface IProvideService {\n  provider(token: Ng1Token, provider: IProvider): IProvider;\n  factory(token: Ng1Token, factory: IInjectable): IProvider;\n  service(token: Ng1Token, type: IInjectable): IProvider;\n  value(token: Ng1Token, value: any): IProvider;\n  constant(token: Ng1Token, value: any): void;\n  decorator(token: Ng1Token, factory: IInjectable): void;\n}\nexport interface IParseService { (expression: string): ICompiledExpression; }\nexport interface ICompiledExpression {\n  (context: any, locals: any): any;\n  assign?: (context: any, value: any) => any;\n}\nexport interface IHttpBackendService {\n  (method: string, url: string, post?: any, callback?: Function, headers?: any, timeout?: number,\n   withCredentials?: boolean): void;\n}\nexport interface ICacheObject {\n  put<T>(key: string, value?: T): T;\n  get(key: string): any;\n}\nexport interface ITemplateCacheService extends ICacheObject {}\nexport interface ITemplateRequestService {\n  (template: string|any /* TrustedResourceUrl */, ignoreRequestError?: boolean): Promise<string>;\n  totalPendingRequests: number;\n}\nexport type IController = string | IInjectable;\nexport interface IControllerService {\n  (controllerConstructor: IController, locals?: any, later?: any, ident?: any): any;\n  (controllerName: string, locals?: any): any;\n}\n\nexport interface IInjectorService {\n  get(key: string): any;\n  has(key: string): boolean;\n}\n\nexport interface IIntervalService {\n  (func: Function, delay: number, count?: number, invokeApply?: boolean,\n   ...args: any[]): Promise<any>;\n  cancel(promise: Promise<any>): boolean;\n}\n\nexport interface ITestabilityService {\n  findBindings(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\n  findModels(element: Element, expression: string, opt_exactMatch?: boolean): Element[];\n  getLocation(): string;\n  setLocation(url: string): void;\n  whenStable(callback: Function): void;\n}\n\nexport interface INgModelController {\n  $render(): void;\n  $isEmpty(value: any): boolean;\n  $setValidity(validationErrorKey: string, isValid: boolean): void;\n  $setPristine(): void;\n  $setDirty(): void;\n  $setUntouched(): void;\n  $setTouched(): void;\n  $rollbackViewValue(): void;\n  $validate(): void;\n  $commitViewValue(): void;\n  $setViewValue(value: any, trigger: string): void;\n\n  $viewValue: any;\n  $modelValue: any;\n  $parsers: Function[];\n  $formatters: Function[];\n  $validators: {[key: string]: Function};\n  $asyncValidators: {[key: string]: Function};\n  $viewChangeListeners: Function[];\n  $error: Object;\n  $pending: Object;\n  $untouched: boolean;\n  $touched: boolean;\n  $pristine: boolean;\n  $dirty: boolean;\n  $valid: boolean;\n  $invalid: boolean;\n  $name: string;\n}\n\nfunction noNg() {\n  throw new Error('AngularJS v1.x is not loaded!');\n}\n\n\nlet angular: {\n  bootstrap: (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) =>\n                 IInjectorService,\n  module: (prefix: string, dependencies?: string[]) => IModule,\n  element: (e: Element | string) => IAugmentedJQuery,\n  version: {major: number},\n  resumeBootstrap: () => void,\n  getTestability: (e: Element) => ITestabilityService\n} = <any>{\n  bootstrap: noNg,\n  module: noNg,\n  element: noNg,\n  version: undefined,\n  resumeBootstrap: noNg,\n  getTestability: noNg\n};\n\ntry {\n  if (window.hasOwnProperty('angular')) {\n    angular = (<any>window).angular;\n  }\n} catch (e) {\n  // ignore in CJS mode.\n}\n\n/**\n * @deprecated Use `setAngularJSGlobal` instead.\n */\nexport function setAngularLib(ng: any): void {\n  setAngularJSGlobal(ng);\n}\n\n/**\n * @deprecated Use `getAngularJSGlobal` instead.\n */\nexport function getAngularLib(): any {\n  return getAngularJSGlobal();\n}\n\n/**\n * Resets the AngularJS global.\n *\n * Used when AngularJS is loaded lazily, and not available on `window`.\n *\n *\n */\nexport function setAngularJSGlobal(ng: any): void {\n  angular = ng;\n  version = ng && ng.version;\n}\n\n/**\n * Returns the current AngularJS global.\n *\n *\n */\nexport function getAngularJSGlobal(): any {\n  return angular;\n}\n\nexport const bootstrap =\n    (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) =>\n        angular.bootstrap(e, modules, config);\n\nexport const module = (prefix: string, dependencies?: string[]) =>\n    angular.module(prefix, dependencies);\n\nexport const element = (e: Element | string) => angular.element(e);\n\nexport const resumeBootstrap = () => angular.resumeBootstrap();\n\nexport const getTestability = (e: Element) => angular.getTestability(e);\n\nexport let version = angular.version;\n"]}