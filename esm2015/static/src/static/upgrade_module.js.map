{"version":3,"file":"upgrade_module.js","sourceRoot":"","sources":["../../../../../../packages/upgrade/static/src/static/upgrade_module.ts"],"names":[],"mappings":";;;;;;;AAQA,OAAO,EAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,WAAW,EAAC,MAAM,eAAe,CAAC;AAEtE,OAAO,KAAK,OAAO,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAC,aAAa,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,YAAY,EAAE,eAAe,EAAE,mBAAmB,EAAC,MAAM,qBAAqB,CAAC;AACjJ,OAAO,EAAgB,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAE5D,OAAO,EAAC,iBAAiB,EAAE,kBAAkB,EAAC,MAAM,sBAAsB,CAAC;AAC3E,OAAO,EAAC,iBAAiB,EAAC,MAAM,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiHzC,MAAM;IAQJ;IAEI,AADA,uDAAuD;IACvD,QAAkB;IAEX,MAAc;QAAd,WAAM,GAAN,MAAM,CAAQ;QACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,iBAAiB,CAAC,QAAQ,CAAC,CAAC;KACjD;;;;;;;IAQD,SAAS,CACL,OAAgB,EAAE,UAAoB,EAAE,EAAE,MAAY;QACxD,MAAM,gBAAgB,GAAG,mBAAmB,GAAG,OAAO,CAAC;;QAGvD,MAAM,UAAU,GACZ,OAAO;aACF,MAAM,CAAC,gBAAgB,EAAE,EAAE,CAAC;aAE5B,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC;aAElC,OAAO,CACJ,eAAe,EACf;YACE,YAAY;YACZ,CAAC,QAAkB,EAAE,EAAE,CAAC,CAAC,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAoB,CAAA;SAC5E,CAAC;aAEL,MAAM,CAAC;YACN,QAAQ,EAAE,SAAS;YACnB,CAAC,QAAiC,EAAE,SAAmC,EAAE,EAAE;gBACzE,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;oBACjC,QAAQ,CAAC,SAAS,CAAC,aAAa,EAAE;wBAChC,SAAS;wBACT,CAAC,mBAAgD,EAAE,EAAE;4BACnD,MAAM,kBAAkB,GAAa,mBAAmB,CAAC,UAAU,CAAC;4BACpE,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;;4BAE/B,MAAM,aAAa,GAAG,UAAS,QAAkB;gCAC/C,kBAAkB,CAAC,IAAI,CAAC,mBAAmB,EAAE;oCAC3C,MAAM,cAAc,GAAgB,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;oCAC9D,EAAE,CAAC,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;wCAC9B,QAAQ,EAAE,CAAC;qCACZ;oCAAC,IAAI,CAAC,CAAC;wCACN,cAAc,CAAC,UAAU,CACrB,aAAa,CAAC,IAAI,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC,CAAC;qCACxD;iCACF,CAAC,CAAC;6BACJ,CAAC;4BAEF,mBAAmB,CAAC,UAAU,GAAG,aAAa,CAAC;4BAC/C,MAAM,CAAC,mBAAmB,CAAC;yBAC5B;qBACF,CAAC,CAAC;iBACJ;gBAED,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBAC7B,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE;wBAC5B,SAAS;wBACT,CAAC,gBAA0C,EAAE,EAAE;;;;4BAI7C,IAAI,eAAe,GACf,CAAC,EAAY,EAAE,KAAa,EAAE,KAAc,EAAE,WAAqB,EAClE,GAAG,IAAW,EAAE,EAAE;gCACjB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,GAAG,EAAE;oCACxC,MAAM,CAAC,gBAAgB,CAAC,CAAC,GAAG,IAAW,EAAE,EAAE;;;;;wCAKzC,UAAU,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;qCAC3D,EAAE,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,CAAC;iCACxC,CAAC,CAAC;6BACJ,CAAC;4BAEL,eAAuB,CAAC,QAAQ,CAAC,GAAG,gBAAgB,CAAC,MAAM,CAAC;4BAC7D,MAAM,CAAC,eAAe,CAAC;yBACxB;qBACF,CAAC,CAAC;iBACJ;aACF;SACF,CAAC;aAED,GAAG,CAAC;YACH,SAAS;YACT,CAAC,SAAmC,EAAE,EAAE;gBACtC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;;gBAG3B,kBAAkB,CAAC,SAAS,CAAC,CAAC;gBAC9B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;;gBAG7B,AADA,4DAA4D;gBAC5D,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,IAAM,CAAC,aAAa,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;;;;gBAK5E,UAAU,CAAC,GAAG,EAAE;oBACd,MAAM,UAAU,GAAG,SAAS,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;oBAC/C,MAAM,YAAY,GACd,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC,CAAC;oBACvE,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,EAAE,GAAG,YAAY,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,CAAC;iBACnE,EAAE,CAAC,CAAC,CAAC;aACP;SACF,CAAC,CAAC;QAEX,MAAM,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,mBAAmB,EAAE,CAAC,gBAAgB,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;;QAG9F,MAAM,aAAa,GAAI,MAAc,CAAC,SAAS,CAAC,CAAC;QACjD,aAAa,CAAC,eAAe,GAAG,SAAS,CAAC;;QAG1C,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;QAGrF,EAAE,CAAC,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC;YAClC,MAAM,uBAAuB,GAAe,aAAa,CAAC,eAAe,CAAC;YAC1E,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;YAC3B,aAAa,CAAC,eAAe,GAAG;gBAC9B,IAAI,IAAI,GAAG,SAAS,CAAC;gBACrB,aAAa,CAAC,eAAe,GAAG,uBAAuB,CAAC;gBACxD,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,aAAa,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;aAC1E,CAAC;SACH;KACF;;;YA7IF,QAAQ,SAAC,EAAC,SAAS,EAAE,CAAC,iBAAiB,CAAC,EAAC;;;;YAvHlC,QAAQ;YAAY,MAAM","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModule, NgZone, Testability} from '@angular/core';\n\nimport * as angular from '../common/angular1';\nimport {$$TESTABILITY, $DELEGATE, $INJECTOR, $INTERVAL, $PROVIDE, INJECTOR_KEY, LAZY_MODULE_REF, UPGRADE_MODULE_NAME} from '../common/constants';\nimport {LazyModuleRef, controllerKey} from '../common/util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\n\n/**\n * @description\n *\n * An `NgModule`, which you import to provide AngularJS core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n *\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\n * library for hybrid upgrade apps that support AoT compilation*\n *\n * The `upgrade/static` package contains helpers that allow AngularJS and Angular components\n * to be used together inside a hybrid upgrade application, which supports AoT compilation.\n *\n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n * 1. Creation of an Angular directive that wraps and exposes an AngularJS component so\n *    that it can be used in an Angular template. See `UpgradeComponent`.\n * 2. Creation of an AngularJS directive that wraps and exposes an Angular component so\n *    that it can be used in an AngularJS template. See `downgradeComponent`.\n * 3. Creation of an Angular root injector provider that wraps and exposes an AngularJS\n *    service so that it can be injected into an Angular context. See\n *    {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an AngularJS service} below.\n * 4. Creation of an AngularJS service that wraps and exposes an Angular injectable\n *    so that it can be injected into an AngularJS context. See `downgradeInjectable`.\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n *    coexisting in a single application. See the\n *    {@link UpgradeModule#examples example} below.\n *\n * ### Mental Model\n *\n * When reasoning about how a hybrid application works it is useful to have a mental model which\n * describes what is happening and explains what is happening at the lowest level.\n *\n * 1. There are two independent frameworks running in a single application, each framework treats\n *    the other as a black box.\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\n *    DOM elements and ignores others.\n * 3. AngularJS directives always execute inside the AngularJS framework codebase regardless of\n *    where they are instantiated.\n * 4. Angular components always execute inside the Angular framework codebase regardless of\n *    where they are instantiated.\n * 5. An AngularJS component can be \"upgraded\"\" to an Angular component. This is achieved by\n *    defining an Angular directive, which bootstraps the AngularJS component at its location\n *    in the DOM. See `UpgradeComponent`.\n * 6. An Angular component can be \"downgraded\"\" to an AngularJS component. This is achieved by\n *    defining an AngularJS directive, which bootstraps the Angular component at its location\n *    in the DOM. See `downgradeComponent`.\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n *    the framework doing the instantiation. The other framework then instantiates and owns the\n *    view for that component.\n *    a. This implies that the component bindings will always follow the semantics of the\n *       instantiation framework.\n *    b. The DOM attributes are parsed by the framework that owns the current template. So\n *       attributes in AngularJS templates must use kebab-case, while AngularJS templates must\n *       use camelCase.\n *    c. However the template binding syntax will always use the Angular style, e.g. square\n *       brackets (`[...]`) for property binding.\n * 8. Angular is bootstrapped first; AngularJS is bootstrapped second. AngularJS always owns the\n *    root component of the application.\n * 9. The new application is running in an Angular zone, and therefore it no longer needs calls\n *    to `$apply()`.\n *\n * ### Core AngularJS services\n * Importing this `NgModule` will add providers for the core\n * [AngularJS services](https://docs.angularjs.org/api/ng/service) to the root injector.\n *\n * ### Bootstrap\n * The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\n * method, which you use to bootstrap the top level AngularJS module onto an element in the\n * DOM for the hybrid upgrade app.\n *\n * It also contains properties to access the {@link UpgradeModule#injector root injector}, the\n * bootstrap `NgZone` and the\n * [AngularJS $injector](https://docs.angularjs.org/api/auto/service/$injector).\n *\n * ### Examples\n *\n * Import the `UpgradeModule` into your top level {@link NgModule Angular `NgModule`}.\n *\n * {@example upgrade/static/ts/module.ts region='ng2-module'}\n *\n * Then bootstrap the hybrid upgrade app's module, get hold of the `UpgradeModule` instance\n * and use it to bootstrap the top level [AngularJS\n * module](https://docs.angularjs.org/api/ng/type/angular.Module).\n *\n * {@example upgrade/static/ts/module.ts region='bootstrap'}\n *\n * {@a upgrading-an-angular-1-service}\n *\n * ### Upgrading an AngularJS service\n *\n * There is no specific API for upgrading an AngularJS service. Instead you should just follow the\n * following recipe:\n *\n * Let's say you have an AngularJS service:\n *\n * {@example upgrade/static/ts/module.ts region=\"ng1-title-case-service\"}\n *\n * Then you should define an Angular provider to be included in your `NgModule` `providers`\n * property.\n *\n * {@example upgrade/static/ts/module.ts region=\"upgrade-ng1-service\"}\n *\n * Then you can use the \"upgraded\" AngularJS service by injecting it into an Angular component\n * or service.\n *\n * {@example upgrade/static/ts/module.ts region=\"use-ng1-upgraded-service\"}\n *\n * @experimental\n */\n@NgModule({providers: [angular1Providers]})\nexport class UpgradeModule {\n  /**\n   * The AngularJS `$injector` for the upgrade application.\n   */\n  public $injector: any /*angular.IInjectorService*/;\n  /** The Angular Injector **/\n  public injector: Injector;\n\n  constructor(\n      /** The root `Injector` for the upgrade application. */\n      injector: Injector,\n      /** The bootstrap zone for the upgrade application */\n      public ngZone: NgZone) {\n    this.injector = new NgAdapterInjector(injector);\n  }\n\n  /**\n   * Bootstrap an AngularJS application from this NgModule\n   * @param element the element on which to bootstrap the AngularJS application\n   * @param [modules] the AngularJS modules to bootstrap for this application\n   * @param [config] optional extra AngularJS bootstrap configuration\n   */\n  bootstrap(\n      element: Element, modules: string[] = [], config?: any /*angular.IAngularBootstrapConfig*/) {\n    const INIT_MODULE_NAME = UPGRADE_MODULE_NAME + '.init';\n\n    // Create an ng1 module to bootstrap\n    const initModule =\n        angular\n            .module(INIT_MODULE_NAME, [])\n\n            .value(INJECTOR_KEY, this.injector)\n\n            .factory(\n                LAZY_MODULE_REF,\n                [\n                  INJECTOR_KEY,\n                  (injector: Injector) => ({ injector, needsNgZone: false } as LazyModuleRef)\n                ])\n\n            .config([\n              $PROVIDE, $INJECTOR,\n              ($provide: angular.IProvideService, $injector: angular.IInjectorService) => {\n                if ($injector.has($$TESTABILITY)) {\n                  $provide.decorator($$TESTABILITY, [\n                    $DELEGATE,\n                    (testabilityDelegate: angular.ITestabilityService) => {\n                      const originalWhenStable: Function = testabilityDelegate.whenStable;\n                      const injector = this.injector;\n                      // Cannot use arrow function below because we need the context\n                      const newWhenStable = function(callback: Function) {\n                        originalWhenStable.call(testabilityDelegate, function() {\n                          const ng2Testability: Testability = injector.get(Testability);\n                          if (ng2Testability.isStable()) {\n                            callback();\n                          } else {\n                            ng2Testability.whenStable(\n                                newWhenStable.bind(testabilityDelegate, callback));\n                          }\n                        });\n                      };\n\n                      testabilityDelegate.whenStable = newWhenStable;\n                      return testabilityDelegate;\n                    }\n                  ]);\n                }\n\n                if ($injector.has($INTERVAL)) {\n                  $provide.decorator($INTERVAL, [\n                    $DELEGATE,\n                    (intervalDelegate: angular.IIntervalService) => {\n                      // Wrap the $interval service so that setInterval is called outside NgZone,\n                      // but the callback is still invoked within it. This is so that $interval\n                      // won't block stability, which preserves the behavior from AngularJS.\n                      let wrappedInterval =\n                          (fn: Function, delay: number, count?: number, invokeApply?: boolean,\n                           ...pass: any[]) => {\n                            return this.ngZone.runOutsideAngular(() => {\n                              return intervalDelegate((...args: any[]) => {\n                                // Run callback in the next VM turn - $interval calls\n                                // $rootScope.$apply, and running the callback in NgZone will\n                                // cause a '$digest already in progress' error if it's in the\n                                // same vm turn.\n                                setTimeout(() => { this.ngZone.run(() => fn(...args)); });\n                              }, delay, count, invokeApply, ...pass);\n                            });\n                          };\n\n                      (wrappedInterval as any)['cancel'] = intervalDelegate.cancel;\n                      return wrappedInterval;\n                    }\n                  ]);\n                }\n              }\n            ])\n\n            .run([\n              $INJECTOR,\n              ($injector: angular.IInjectorService) => {\n                this.$injector = $injector;\n\n                // Initialize the ng1 $injector provider\n                setTempInjectorRef($injector);\n                this.injector.get($INJECTOR);\n\n                // Put the injector on the DOM, so that it can be \"required\"\n                angular.element(element).data !(controllerKey(INJECTOR_KEY), this.injector);\n\n                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n                // We need to do this in the next tick so that we don't prevent the bootup\n                // stabilizing\n                setTimeout(() => {\n                  const $rootScope = $injector.get('$rootScope');\n                  const subscription =\n                      this.ngZone.onMicrotaskEmpty.subscribe(() => $rootScope.$digest());\n                  $rootScope.$on('$destroy', () => { subscription.unsubscribe(); });\n                }, 0);\n              }\n            ]);\n\n    const upgradeModule = angular.module(UPGRADE_MODULE_NAME, [INIT_MODULE_NAME].concat(modules));\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const windowAngular = (window as any)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the AngularJS application inside our zone\n    this.ngZone.run(() => { angular.bootstrap(element, [upgradeModule.name], config); });\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function() {\n        let args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        return ngZone.run(() => windowAngular.resumeBootstrap.apply(this, args));\n      };\n    }\n  }\n}\n"]}