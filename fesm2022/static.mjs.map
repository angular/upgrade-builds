{"version":3,"file":"static.mjs","sources":["../../../../../../packages/upgrade/static/src/angular1_providers.ts","../../../../../../packages/upgrade/static/src/util.ts","../../../../../../packages/upgrade/static/src/downgrade_module.ts","../../../../../../packages/upgrade/static/src/upgrade_component.ts","../../../../../../packages/upgrade/static/src/upgrade_module.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {IInjectorService} from '../../src/common/src/angular1';\n\n// We have to do a little dance to get the ng1 injector into the module injector.\n// We store the ng1 injector so that the provider in the module injector can access it\n// Then we \"get\" the ng1 injector from the module injector, which triggers the provider to read\n// the stored injector and release the reference to it.\nlet tempInjectorRef: IInjectorService | null = null;\nexport function setTempInjectorRef(injector: IInjectorService) {\n  tempInjectorRef = injector;\n}\nexport function injectorFactory() {\n  if (!tempInjectorRef) {\n    throw new Error('Trying to get the AngularJS injector before it being set.');\n  }\n\n  const injector: IInjectorService = tempInjectorRef;\n  tempInjectorRef = null; // clear the value to prevent memory leaks\n  return injector;\n}\n\nexport function rootScopeFactory(i: IInjectorService) {\n  return i.get('$rootScope');\n}\n\nexport function compileFactory(i: IInjectorService) {\n  return i.get('$compile');\n}\n\nexport function parseFactory(i: IInjectorService) {\n  return i.get('$parse');\n}\n\nexport const angular1Providers = [\n  // We must use exported named functions for the ng2 factories to keep the compiler happy:\n  // > Metadata collected contains an error that will be reported at runtime:\n  // >   Function calls are not supported.\n  // >   Consider replacing the function or lambda with a reference to an exported function\n  {provide: '$injector', useFactory: injectorFactory, deps: []},\n  {provide: '$rootScope', useFactory: rootScopeFactory, deps: ['$injector']},\n  {provide: '$compile', useFactory: compileFactory, deps: ['$injector']},\n  {provide: '$parse', useFactory: parseFactory, deps: ['$injector']},\n];\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Injector,\n  ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,\n} from '@angular/core';\n\nexport class NgAdapterInjector implements Injector {\n  constructor(private modInjector: Injector) {}\n\n  // When Angular locate a service in the component injector tree, the not found value is set to\n  // `NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR`. In such a case we should not walk up to the module\n  // injector.\n  // AngularJS only supports a single tree and should always check the module injector.\n  get(token: any, notFoundValue?: any): any {\n    if (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n      return notFoundValue;\n    }\n\n    return this.modInjector.get(token, notFoundValue);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Injector,\n  NgModuleFactory,\n  NgModuleRef,\n  PlatformRef,\n  StaticProvider,\n  Type,\n} from '@angular/core';\nimport {platformBrowser} from '@angular/platform-browser';\n\nimport {ɵangular1, ɵconstants, ɵutil} from '../common';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\nlet moduleUid = 0;\n\n/**\n * @description\n *\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\n * instantiated.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\n * support AOT compilation.*\n *\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\n * routes.\n *\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\n * reference will be used from that point onwards.\n *\n * `downgradeModule()` requires either an `NgModuleFactory`, `NgModule` class or a function:\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\n *   NOTE: this type of the argument is deprecated. Please either provide an `NgModule` class or a\n *   bootstrap function instead.\n * - `NgModule` class: If you pass an NgModule class, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModule bootstrapModule()}.\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\n *\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\n * declare a dependency in your main AngularJS module.\n *\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\n *\n * For more details on how to use `downgradeModule()` see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * @usageNotes\n *\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\n * component.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\n *   Use one or the other.\n *\n * </div>\n *\n * ### Differences with `UpgradeModule`\n *\n * Besides their different API, there are two important internal differences between\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\n *\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\n *    inside the {@link NgZone Angular zone}.\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\n *    detected in the Angular part of the application.\n *\n * What this means is that applications using `UpgradeModule` will run change detection more\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\n * This will inevitably result in more change detection runs than necessary.\n *\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\n * notify each framework as needed.\n *\n * For a more detailed discussion of the differences and their implications, see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n *   You can manually trigger a change detection run in AngularJS using\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\n *\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\n *   ngZone.run(...)}.\n *\n * </div>\n *\n * ### Downgrading multiple modules\n *\n * It is possible to downgrade multiple modules and include them in an AngularJS application. In\n * that case, each downgraded module will be bootstrapped when an associated downgraded component or\n * injectable needs to be instantiated.\n *\n * Things to keep in mind, when downgrading multiple modules:\n *\n * - Each downgraded component/injectable needs to be explicitly associated with a downgraded\n *   module. See `downgradeComponent()` and `downgradeInjectable()` for more details.\n *\n * - If you want some injectables to be shared among all downgraded modules, you can provide them as\n *   `StaticProvider`s, when creating the `PlatformRef` (e.g. via `platformBrowser` or\n *   `platformBrowserDynamic`).\n *\n * - When using {@link PlatformRef#bootstrapmodule `bootstrapModule()`} or\n *   {@link PlatformRef#bootstrapmodulefactory `bootstrapModuleFactory()`} to bootstrap the\n *   downgraded modules, each one is considered a \"root\" module. As a consequence, a new instance\n *   will be created for every injectable provided in `\"root\"` (via\n *   {@link /api/core/Injectable#providedIn providedIn}\n *   If this is not your intention, you can have a shared module (that will act as act as the \"root\"\n *   module) and create all downgraded modules using that module's injector:\n *\n *   {@example upgrade/static/ts/lite-multi-shared/module.ts region=\"shared-root-module\"}\n *\n * @publicApi\n */\nexport function downgradeModule<T>(\n  moduleOrBootstrapFn: Type<T> | ((extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>),\n): string;\n/**\n * @description\n *\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\n * instantiated.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\n * support AOT compilation.*\n *\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\n * routes.\n *\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\n * reference will be used from that point onwards.\n *\n * `downgradeModule()` requires either an `NgModuleFactory`, `NgModule` class or a function:\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\n *   NOTE: this type of the argument is deprecated. Please either provide an `NgModule` class or a\n *   bootstrap function instead.\n * - `NgModule` class: If you pass an NgModule class, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModule bootstrapModule()}.\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\n *\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\n * declare a dependency in your main AngularJS module.\n *\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\n *\n * For more details on how to use `downgradeModule()` see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * @usageNotes\n *\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\n * component.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\n *   Use one or the other.\n *\n * </div>\n *\n * ### Differences with `UpgradeModule`\n *\n * Besides their different API, there are two important internal differences between\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\n *\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\n *    inside the {@link NgZone Angular zone}.\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\n *    detected in the Angular part of the application.\n *\n * What this means is that applications using `UpgradeModule` will run change detection more\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\n * This will inevitably result in more change detection runs than necessary.\n *\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\n * notify each framework as needed.\n *\n * For a more detailed discussion of the differences and their implications, see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n *   You can manually trigger a change detection run in AngularJS using\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\n *\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\n *   ngZone.run(...)}.\n *\n * </div>\n *\n * ### Downgrading multiple modules\n *\n * It is possible to downgrade multiple modules and include them in an AngularJS application. In\n * that case, each downgraded module will be bootstrapped when an associated downgraded component or\n * injectable needs to be instantiated.\n *\n * Things to keep in mind, when downgrading multiple modules:\n *\n * - Each downgraded component/injectable needs to be explicitly associated with a downgraded\n *   module. See `downgradeComponent()` and `downgradeInjectable()` for more details.\n *\n * - If you want some injectables to be shared among all downgraded modules, you can provide them as\n *   `StaticProvider`s, when creating the `PlatformRef` (e.g. via `platformBrowser` or\n *   `platformBrowserDynamic`).\n *\n * - When using {@link PlatformRef#bootstrapmodule `bootstrapModule()`} or\n *   {@link PlatformRef#bootstrapmodulefactory `bootstrapModuleFactory()`} to bootstrap the\n *   downgraded modules, each one is considered a \"root\" module. As a consequence, a new instance\n *   will be created for every injectable provided in `\"root\"` (via\n *   {@link /api/core/Injectable#providedIn providedIn}\n *   If this is not your intention, you can have a shared module (that will act as act as the \"root\"\n *   module) and create all downgraded modules using that module's injector:\n *\n *   {@example upgrade/static/ts/lite-multi-shared/module.ts region=\"shared-root-module\"}\n *\n * @publicApi\n *\n * @deprecated Passing `NgModuleFactory` as the `downgradeModule` function argument is deprecated,\n *     please pass an NgModule class reference instead.\n */\nexport function downgradeModule<T>(moduleOrBootstrapFn: NgModuleFactory<T>): string;\n/**\n * @description\n *\n * A helper function for creating an AngularJS module that can bootstrap an Angular module\n * \"on-demand\" (possibly lazily) when a {@link downgradeComponent downgraded component} needs to be\n * instantiated.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static) library for hybrid upgrade apps that\n * support AOT compilation.*\n *\n * It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to\n * pay the cost up-front. For example, you can have an AngularJS application that uses Angular for\n * specific routes and only instantiate the Angular modules if/when the user visits one of these\n * routes.\n *\n * The Angular module will be bootstrapped once (when requested for the first time) and the same\n * reference will be used from that point onwards.\n *\n * `downgradeModule()` requires either an `NgModuleFactory`, `NgModule` class or a function:\n * - `NgModuleFactory`: If you pass an `NgModuleFactory`, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModuleFactory bootstrapModuleFactory()}.\n *   NOTE: this type of the argument is deprecated. Please either provide an `NgModule` class or a\n *   bootstrap function instead.\n * - `NgModule` class: If you pass an NgModule class, it will be used to instantiate a module\n *   using `platformBrowser`'s {@link PlatformRef#bootstrapModule bootstrapModule()}.\n * - `Function`: If you pass a function, it is expected to return a promise resolving to an\n *   `NgModuleRef`. The function is called with an array of extra {@link StaticProvider Providers}\n *   that are expected to be available from the returned `NgModuleRef`'s `Injector`.\n *\n * `downgradeModule()` returns the name of the created AngularJS wrapper module. You can use it to\n * declare a dependency in your main AngularJS module.\n *\n * {@example upgrade/static/ts/lite/module.ts region=\"basic-how-to\"}\n *\n * For more details on how to use `downgradeModule()` see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * @usageNotes\n *\n * Apart from `UpgradeModule`, you can use the rest of the `upgrade/static` helpers as usual to\n * build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be\n * available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded\n * component.\n *\n * <div class=\"docs-alert docs-alert-important\">\n *\n *   You cannot use `downgradeModule()` and `UpgradeModule` in the same hybrid application.<br />\n *   Use one or the other.\n *\n * </div>\n *\n * ### Differences with `UpgradeModule`\n *\n * Besides their different API, there are two important internal differences between\n * `downgradeModule()` and `UpgradeModule` that affect the behavior of hybrid applications:\n *\n * 1. Unlike `UpgradeModule`, `downgradeModule()` does not bootstrap the main AngularJS module\n *    inside the {@link NgZone Angular zone}.\n * 2. Unlike `UpgradeModule`, `downgradeModule()` does not automatically run a\n *    [$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest) when changes are\n *    detected in the Angular part of the application.\n *\n * What this means is that applications using `UpgradeModule` will run change detection more\n * frequently in order to ensure that both frameworks are properly notified about possible changes.\n * This will inevitably result in more change detection runs than necessary.\n *\n * `downgradeModule()`, on the other side, does not try to tie the two change detection systems as\n * tightly, restricting the explicit change detection runs only to cases where it knows it is\n * necessary (e.g. when the inputs of a downgraded component change). This improves performance,\n * especially in change-detection-heavy applications, but leaves it up to the developer to manually\n * notify each framework as needed.\n *\n * For a more detailed discussion of the differences and their implications, see\n * [Upgrading for Performance](https://angular.io/guide/upgrade).\n *\n * <div class=\"docs-alert docs-alert-helpful\">\n *\n *   You can manually trigger a change detection run in AngularJS using\n *   [scope.$apply(...)](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply) or\n *   [$rootScope.$digest()](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest).\n *\n *   You can manually trigger a change detection run in Angular using {@link NgZone#run\n *   ngZone.run(...)}.\n *\n * </div>\n *\n * ### Downgrading multiple modules\n *\n * It is possible to downgrade multiple modules and include them in an AngularJS application. In\n * that case, each downgraded module will be bootstrapped when an associated downgraded component or\n * injectable needs to be instantiated.\n *\n * Things to keep in mind, when downgrading multiple modules:\n *\n * - Each downgraded component/injectable needs to be explicitly associated with a downgraded\n *   module. See `downgradeComponent()` and `downgradeInjectable()` for more details.\n *\n * - If you want some injectables to be shared among all downgraded modules, you can provide them as\n *   `StaticProvider`s, when creating the `PlatformRef` (e.g. via `platformBrowser` or\n *   `platformBrowserDynamic`).\n *\n * - When using {@link PlatformRef#bootstrapmodule `bootstrapModule()`} or\n *   {@link PlatformRef#bootstrapmodulefactory `bootstrapModuleFactory()`} to bootstrap the\n *   downgraded modules, each one is considered a \"root\" module. As a consequence, a new instance\n *   will be created for every injectable provided in `\"root\"` (via\n *   {@link /api/core/Injectable#providedIn providedIn}\n *   If this is not your intention, you can have a shared module (that will act as act as the \"root\"\n *   module) and create all downgraded modules using that module's injector:\n *\n *   {@example upgrade/static/ts/lite-multi-shared/module.ts region=\"shared-root-module\"}\n *\n * @publicApi\n */\nexport function downgradeModule<T>(\n  moduleOrBootstrapFn:\n    | Type<T>\n    | NgModuleFactory<T>\n    | ((extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>),\n): string {\n  const lazyModuleName = `${ɵconstants.UPGRADE_MODULE_NAME}.lazy${++moduleUid}`;\n  const lazyModuleRefKey = `${ɵconstants.LAZY_MODULE_REF}${lazyModuleName}`;\n  const lazyInjectorKey = `${ɵconstants.INJECTOR_KEY}${lazyModuleName}`;\n\n  let bootstrapFn: (extraProviders: StaticProvider[]) => Promise<NgModuleRef<T>>;\n  if (ɵutil.isNgModuleType(moduleOrBootstrapFn)) {\n    // NgModule class\n    bootstrapFn = (extraProviders: StaticProvider[]) =>\n      platformBrowser(extraProviders).bootstrapModule(moduleOrBootstrapFn);\n  } else if (!ɵutil.isFunction(moduleOrBootstrapFn)) {\n    // NgModule factory\n    bootstrapFn = (extraProviders: StaticProvider[]) =>\n      platformBrowser(extraProviders).bootstrapModuleFactory(moduleOrBootstrapFn);\n  } else {\n    // bootstrap function\n    bootstrapFn = moduleOrBootstrapFn;\n  }\n\n  let injector: Injector;\n\n  // Create an ng1 module to bootstrap.\n  ɵangular1\n    .module_(lazyModuleName, [])\n    .constant(ɵconstants.UPGRADE_APP_TYPE_KEY, ɵutil.UpgradeAppType.Lite)\n    .factory(ɵconstants.INJECTOR_KEY, [lazyInjectorKey, identity])\n    .factory(lazyInjectorKey, () => {\n      if (!injector) {\n        throw new Error(\n          'Trying to get the Angular injector before bootstrapping the corresponding ' +\n            'Angular module.',\n        );\n      }\n      return injector;\n    })\n    .factory(ɵconstants.LAZY_MODULE_REF, [lazyModuleRefKey, identity])\n    .factory(lazyModuleRefKey, [\n      ɵconstants.$INJECTOR,\n      ($injector: ɵangular1.IInjectorService) => {\n        setTempInjectorRef($injector);\n        const result: ɵutil.LazyModuleRef = {\n          promise: bootstrapFn(angular1Providers).then((ref) => {\n            injector = result.injector = new NgAdapterInjector(ref.injector);\n            injector.get(ɵconstants.$INJECTOR);\n\n            // Destroy the AngularJS app once the Angular `PlatformRef` is destroyed.\n            // This does not happen in a typical SPA scenario, but it might be useful for\n            // other use-cases where disposing of an Angular/AngularJS app is necessary\n            // (such as Hot Module Replacement (HMR)).\n            // See https://github.com/angular/angular/issues/39935.\n            injector.get(PlatformRef).onDestroy(() => ɵutil.destroyApp($injector));\n\n            return injector;\n          }),\n        };\n        return result;\n      },\n    ])\n    .config([\n      ɵconstants.$INJECTOR,\n      ɵconstants.$PROVIDE,\n      ($injector: ɵangular1.IInjectorService, $provide: ɵangular1.IProvideService) => {\n        $provide.constant(\n          ɵconstants.DOWNGRADED_MODULE_COUNT_KEY,\n          ɵutil.getDowngradedModuleCount($injector) + 1,\n        );\n      },\n    ]);\n\n  return lazyModuleName;\n}\n\nfunction identity<T = any>(x: T): T {\n  return x;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Directive,\n  DoCheck,\n  ElementRef,\n  EventEmitter,\n  Injector,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  SimpleChanges,\n} from '@angular/core';\n\nimport {ɵangular1, ɵconstants, ɵupgradeHelper, ɵutil} from '../common';\n\nconst NOT_SUPPORTED: any = 'NOT_SUPPORTED';\nconst INITIAL_VALUE = {\n  __UNINITIALIZED__: true,\n};\n\nclass Bindings {\n  twoWayBoundProperties: string[] = [];\n  twoWayBoundLastValues: any[] = [];\n\n  expressionBoundProperties: string[] = [];\n\n  propertyToOutputMap: {[propName: string]: string} = {};\n}\n\n/**\n * @description\n *\n * A helper class that allows an AngularJS component to be used from Angular.\n *\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\n * library for hybrid upgrade apps that support AOT compilation.*\n *\n * This helper class should be used as a base class for creating Angular directives\n * that wrap AngularJS components that need to be \"upgraded\".\n *\n * @usageNotes\n * ### Examples\n *\n * Let's assume that you have an AngularJS component called `ng1Hero` that needs\n * to be made available in Angular templates.\n *\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero\"}\n *\n * We must create a `Directive` that will make this AngularJS component\n * available inside Angular templates.\n *\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero-wrapper\"}\n *\n * In this example you can see that we must derive from the `UpgradeComponent`\n * base class but also provide an {@link Directive `@Directive`} decorator. This is\n * because the AOT compiler requires that this information is statically available at\n * compile time.\n *\n * Note that we must do the following:\n * * specify the directive's selector (`ng1-hero`)\n * * specify all inputs and outputs that the AngularJS component expects\n * * derive from `UpgradeComponent`\n * * call the base class from the constructor, passing\n *   * the AngularJS name of the component (`ng1Hero`)\n *   * the `ElementRef` and `Injector` for the component wrapper\n *\n * @publicApi\n * @extensible\n */\n@Directive()\nexport class UpgradeComponent implements OnInit, OnChanges, DoCheck, OnDestroy {\n  private helper: ɵupgradeHelper.UpgradeHelper;\n\n  private $element: ɵangular1.IAugmentedJQuery;\n  private $componentScope: ɵangular1.IScope;\n\n  private directive: ɵangular1.IDirective;\n  private bindings: Bindings;\n\n  private controllerInstance?: ɵupgradeHelper.IControllerInstance;\n  private bindingDestination?: ɵupgradeHelper.IBindingDestination;\n\n  // We will be instantiating the controller in the `ngOnInit` hook, when the\n  // first `ngOnChanges` will have been already triggered. We store the\n  // `SimpleChanges` and \"play them back\" later.\n  private pendingChanges: SimpleChanges | null = null;\n\n  private unregisterDoCheckWatcher?: Function;\n\n  /**\n   * Create a new `UpgradeComponent` instance. You should not normally need to do this.\n   * Instead you should derive a new class from this one and call the super constructor\n   * from the base class.\n   *\n   * {@example upgrade/static/ts/full/module.ts region=\"ng1-hero-wrapper\" }\n   *\n   * * The `name` parameter should be the name of the AngularJS directive.\n   * * The `elementRef` and `injector` parameters should be acquired from Angular by dependency\n   *   injection into the base class constructor.\n   */\n  constructor(name: string, elementRef: ElementRef, injector: Injector) {\n    this.helper = new ɵupgradeHelper.UpgradeHelper(injector, name, elementRef);\n\n    this.$element = this.helper.$element;\n\n    this.directive = this.helper.directive;\n    this.bindings = this.initializeBindings(this.directive, name);\n\n    // We ask for the AngularJS scope from the Angular injector, since\n    // we will put the new component scope onto the new injector for each component\n    const $parentScope = injector.get(ɵconstants.$SCOPE);\n    // QUESTION 1: Should we create an isolated scope if the scope is only true?\n    // QUESTION 2: Should we make the scope accessible through `$element.scope()/isolateScope()`?\n    this.$componentScope = $parentScope.$new(!!this.directive.scope);\n\n    this.initializeOutputs();\n  }\n\n  /** @nodoc */\n  ngOnInit() {\n    // Collect contents, insert and compile template\n    const attachChildNodes: ɵangular1.ILinkFn | undefined = this.helper.prepareTransclusion();\n    const linkFn = this.helper.compileTemplate();\n\n    // Instantiate controller\n    const controllerType = this.directive.controller;\n    const bindToController = this.directive.bindToController;\n    let controllerInstance = controllerType\n      ? this.helper.buildController(controllerType, this.$componentScope)\n      : undefined;\n    let bindingDestination: ɵupgradeHelper.IBindingDestination;\n\n    if (!bindToController) {\n      bindingDestination = this.$componentScope;\n    } else if (controllerType && controllerInstance) {\n      bindingDestination = controllerInstance;\n    } else {\n      throw new Error(\n        `Upgraded directive '${this.directive.name}' specifies 'bindToController' but no controller.`,\n      );\n    }\n    this.controllerInstance = controllerInstance;\n    this.bindingDestination = bindingDestination;\n\n    // Set up outputs\n    this.bindOutputs(bindingDestination);\n\n    // Require other controllers\n    const requiredControllers = this.helper.resolveAndBindRequiredControllers(controllerInstance);\n\n    // Hook: $onChanges\n    if (this.pendingChanges) {\n      this.forwardChanges(this.pendingChanges, bindingDestination);\n      this.pendingChanges = null;\n    }\n\n    // Hook: $onInit\n    if (this.controllerInstance && ɵutil.isFunction(this.controllerInstance.$onInit)) {\n      this.controllerInstance.$onInit();\n    }\n\n    // Hook: $doCheck\n    if (controllerInstance && ɵutil.isFunction(controllerInstance.$doCheck)) {\n      const callDoCheck = () => controllerInstance?.$doCheck?.();\n\n      this.unregisterDoCheckWatcher = this.$componentScope.$parent.$watch(callDoCheck);\n      callDoCheck();\n    }\n\n    // Linking\n    const link = this.directive.link;\n    const preLink = typeof link == 'object' && link.pre;\n    const postLink = typeof link == 'object' ? link.post : link;\n    const attrs: ɵangular1.IAttributes = NOT_SUPPORTED;\n    const transcludeFn: ɵangular1.ITranscludeFunction = NOT_SUPPORTED;\n    if (preLink) {\n      preLink(this.$componentScope, this.$element, attrs, requiredControllers, transcludeFn);\n    }\n\n    linkFn(this.$componentScope, null!, {parentBoundTranscludeFn: attachChildNodes});\n\n    if (postLink) {\n      postLink(this.$componentScope, this.$element, attrs, requiredControllers, transcludeFn);\n    }\n\n    // Hook: $postLink\n    if (this.controllerInstance && ɵutil.isFunction(this.controllerInstance.$postLink)) {\n      this.controllerInstance.$postLink();\n    }\n  }\n\n  /** @nodoc */\n  ngOnChanges(changes: SimpleChanges) {\n    if (!this.bindingDestination) {\n      this.pendingChanges = changes;\n    } else {\n      this.forwardChanges(changes, this.bindingDestination);\n    }\n  }\n\n  /** @nodoc */\n  ngDoCheck() {\n    const twoWayBoundProperties = this.bindings.twoWayBoundProperties;\n    const twoWayBoundLastValues = this.bindings.twoWayBoundLastValues;\n    const propertyToOutputMap = this.bindings.propertyToOutputMap;\n\n    twoWayBoundProperties.forEach((propName, idx) => {\n      const newValue = this.bindingDestination?.[propName];\n      const oldValue = twoWayBoundLastValues[idx];\n\n      if (!Object.is(newValue, oldValue)) {\n        const outputName = propertyToOutputMap[propName];\n        const eventEmitter: EventEmitter<any> = (this as any)[outputName];\n\n        eventEmitter.emit(newValue);\n        twoWayBoundLastValues[idx] = newValue;\n      }\n    });\n  }\n\n  /** @nodoc */\n  ngOnDestroy() {\n    if (ɵutil.isFunction(this.unregisterDoCheckWatcher)) {\n      this.unregisterDoCheckWatcher();\n    }\n    this.helper.onDestroy(this.$componentScope, this.controllerInstance);\n  }\n\n  private initializeBindings(directive: ɵangular1.IDirective, name: string) {\n    const btcIsObject = typeof directive.bindToController === 'object';\n    if (btcIsObject && Object.keys(directive.scope!).length) {\n      throw new Error(\n        `Binding definitions on scope and controller at the same time is not supported.`,\n      );\n    }\n\n    const context = btcIsObject ? directive.bindToController : directive.scope;\n    const bindings = new Bindings();\n\n    if (typeof context == 'object') {\n      Object.keys(context).forEach((propName) => {\n        const definition = context[propName];\n        const bindingType = definition.charAt(0);\n\n        // QUESTION: What about `=*`? Ignore? Throw? Support?\n\n        switch (bindingType) {\n          case '@':\n          case '<':\n            // We don't need to do anything special. They will be defined as inputs on the\n            // upgraded component facade and the change propagation will be handled by\n            // `ngOnChanges()`.\n            break;\n          case '=':\n            bindings.twoWayBoundProperties.push(propName);\n            bindings.twoWayBoundLastValues.push(INITIAL_VALUE);\n            bindings.propertyToOutputMap[propName] = propName + 'Change';\n            break;\n          case '&':\n            bindings.expressionBoundProperties.push(propName);\n            bindings.propertyToOutputMap[propName] = propName;\n            break;\n          default:\n            let json = JSON.stringify(context);\n            throw new Error(\n              `Unexpected mapping '${bindingType}' in '${json}' in '${name}' directive.`,\n            );\n        }\n      });\n    }\n\n    return bindings;\n  }\n\n  private initializeOutputs() {\n    // Initialize the outputs for `=` and `&` bindings\n    this.bindings.twoWayBoundProperties\n      .concat(this.bindings.expressionBoundProperties)\n      .forEach((propName) => {\n        const outputName = this.bindings.propertyToOutputMap[propName];\n        (this as any)[outputName] = new EventEmitter();\n      });\n  }\n\n  private bindOutputs(bindingDestination: ɵupgradeHelper.IBindingDestination) {\n    // Bind `&` bindings to the corresponding outputs\n    this.bindings.expressionBoundProperties.forEach((propName) => {\n      const outputName = this.bindings.propertyToOutputMap[propName];\n      const emitter: EventEmitter<any> = (this as any)[outputName];\n\n      bindingDestination[propName] = (value: any) => emitter.emit(value);\n    });\n  }\n\n  private forwardChanges(\n    changes: SimpleChanges,\n    bindingDestination: ɵupgradeHelper.IBindingDestination,\n  ) {\n    // Forward input changes to `bindingDestination`\n    Object.keys(changes).forEach(\n      (propName) => (bindingDestination[propName] = changes[propName].currentValue),\n    );\n\n    if (ɵutil.isFunction(bindingDestination.$onChanges)) {\n      bindingDestination.$onChanges(changes);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Injector, NgModule, NgZone, PlatformRef, Testability} from '@angular/core';\n\nimport {ɵangular1, ɵconstants, ɵutil} from '../common';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\n/**\n * @description\n *\n * An `NgModule`, which you import to provide AngularJS core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n *\n * *Part of the [upgrade/static](api?query=upgrade/static)\n * library for hybrid upgrade apps that support AOT compilation*\n *\n * The `upgrade/static` package contains helpers that allow AngularJS and Angular components\n * to be used together inside a hybrid upgrade application, which supports AOT compilation.\n *\n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n *\n * 1. Creation of an Angular directive that wraps and exposes an AngularJS component so\n *    that it can be used in an Angular template. See `UpgradeComponent`.\n * 2. Creation of an AngularJS directive that wraps and exposes an Angular component so\n *    that it can be used in an AngularJS template. See `downgradeComponent`.\n * 3. Creation of an Angular root injector provider that wraps and exposes an AngularJS\n *    service so that it can be injected into an Angular context. See\n *    {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an AngularJS service} below.\n * 4. Creation of an AngularJS service that wraps and exposes an Angular injectable\n *    so that it can be injected into an AngularJS context. See `downgradeInjectable`.\n * 5. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n *    coexisting in a single application.\n *\n * @usageNotes\n *\n * ```ts\n * import {UpgradeModule} from '@angular/upgrade/static';\n * ```\n *\n * See also the {@link UpgradeModule#examples examples} below.\n *\n * ### Mental Model\n *\n * When reasoning about how a hybrid application works it is useful to have a mental model which\n * describes what is happening and explains what is happening at the lowest level.\n *\n * 1. There are two independent frameworks running in a single application, each framework treats\n *    the other as a black box.\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\n *    DOM elements and ignores others.\n * 3. AngularJS directives always execute inside the AngularJS framework codebase regardless of\n *    where they are instantiated.\n * 4. Angular components always execute inside the Angular framework codebase regardless of\n *    where they are instantiated.\n * 5. An AngularJS component can be \"upgraded\"\" to an Angular component. This is achieved by\n *    defining an Angular directive, which bootstraps the AngularJS component at its location\n *    in the DOM. See `UpgradeComponent`.\n * 6. An Angular component can be \"downgraded\" to an AngularJS component. This is achieved by\n *    defining an AngularJS directive, which bootstraps the Angular component at its location\n *    in the DOM. See `downgradeComponent`.\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n *    the framework doing the instantiation. The other framework then instantiates and owns the\n *    view for that component.\n *    1. This implies that the component bindings will always follow the semantics of the\n *       instantiation framework.\n *    2. The DOM attributes are parsed by the framework that owns the current template. So\n *       attributes in AngularJS templates must use kebab-case, while AngularJS templates must use\n *       camelCase.\n *    3. However the template binding syntax will always use the Angular style, e.g. square\n *       brackets (`[...]`) for property binding.\n * 8. Angular is bootstrapped first; AngularJS is bootstrapped second. AngularJS always owns the\n *    root component of the application.\n * 9. The new application is running in an Angular zone, and therefore it no longer needs calls to\n *    `$apply()`.\n *\n * ### The `UpgradeModule` class\n *\n * This class is an `NgModule`, which you import to provide AngularJS core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n *\n * * Core AngularJS services<br />\n *   Importing this `NgModule` will add providers for the core\n *   [AngularJS services](https://docs.angularjs.org/api/ng/service) to the root injector.\n *\n * * Bootstrap<br />\n *   The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\n *   method, which you use to bootstrap the top level AngularJS module onto an element in the\n *   DOM for the hybrid upgrade app.\n *\n *   It also contains properties to access the {@link UpgradeModule#injector root injector}, the\n *   bootstrap `NgZone` and the\n *   [AngularJS $injector](https://docs.angularjs.org/api/auto/service/$injector).\n *\n * ### Examples\n *\n * Import the `UpgradeModule` into your top level Angular {@link NgModule NgModule}.\n *\n * {@example upgrade/static/ts/full/module.ts region='ng2-module'}\n *\n * Then inject `UpgradeModule` into your Angular `NgModule` and use it to bootstrap the top level\n * [AngularJS module](https://docs.angularjs.org/api/ng/type/angular.Module) in the\n * `ngDoBootstrap()` method.\n *\n * {@example upgrade/static/ts/full/module.ts region='bootstrap-ng1'}\n *\n * Finally, kick off the whole process, by bootstrapping your top level Angular `NgModule`.\n *\n * {@example upgrade/static/ts/full/module.ts region='bootstrap-ng2'}\n *\n * ### Upgrading an AngularJS service\n *\n * There is no specific API for upgrading an AngularJS service. Instead you should just follow the\n * following recipe:\n *\n * Let's say you have an AngularJS service:\n *\n * {@example upgrade/static/ts/full/module.ts region=\"ng1-text-formatter-service\"}\n *\n * Then you should define an Angular provider to be included in your `NgModule` `providers`\n * property.\n *\n * {@example upgrade/static/ts/full/module.ts region=\"upgrade-ng1-service\"}\n *\n * Then you can use the \"upgraded\" AngularJS service by injecting it into an Angular component\n * or service.\n *\n * {@example upgrade/static/ts/full/module.ts region=\"use-ng1-upgraded-service\"}\n *\n * @publicApi\n */\n@NgModule({providers: [angular1Providers]})\nexport class UpgradeModule {\n  /**\n   * The AngularJS `$injector` for the upgrade application.\n   */\n  public $injector: any /*angular.IInjectorService*/;\n  /** The Angular Injector **/\n  public injector: Injector;\n\n  constructor(\n    /** The root `Injector` for the upgrade application. */\n    injector: Injector,\n    /** The bootstrap zone for the upgrade application */\n    public ngZone: NgZone,\n    /**\n     * The owning `NgModuleRef`s `PlatformRef` instance.\n     * This is used to tie the lifecycle of the bootstrapped AngularJS apps to that of the Angular\n     * `PlatformRef`.\n     */\n    private platformRef: PlatformRef,\n  ) {\n    this.injector = new NgAdapterInjector(injector);\n  }\n\n  /**\n   * Bootstrap an AngularJS application from this NgModule\n   * @param element the element on which to bootstrap the AngularJS application\n   * @param [modules] the AngularJS modules to bootstrap for this application\n   * @param [config] optional extra AngularJS bootstrap configuration\n   * @return The value returned by\n   *     [angular.bootstrap()](https://docs.angularjs.org/api/ng/function/angular.bootstrap).\n   */\n  bootstrap(\n    element: Element,\n    modules: string[] = [],\n    config?: any /*angular.IAngularBootstrapConfig*/,\n  ): any /*ReturnType<typeof angular.bootstrap>*/ {\n    const INIT_MODULE_NAME = ɵconstants.UPGRADE_MODULE_NAME + '.init';\n\n    // Create an ng1 module to bootstrap\n    ɵangular1\n      .module_(INIT_MODULE_NAME, [])\n\n      .constant(ɵconstants.UPGRADE_APP_TYPE_KEY, ɵutil.UpgradeAppType.Static)\n\n      .value(ɵconstants.INJECTOR_KEY, this.injector)\n\n      .factory(ɵconstants.LAZY_MODULE_REF, [\n        ɵconstants.INJECTOR_KEY,\n        (injector: Injector) => ({injector}) as ɵutil.LazyModuleRef,\n      ])\n\n      .config([\n        ɵconstants.$PROVIDE,\n        ɵconstants.$INJECTOR,\n        ($provide: ɵangular1.IProvideService, $injector: ɵangular1.IInjectorService) => {\n          if ($injector.has(ɵconstants.$$TESTABILITY)) {\n            $provide.decorator(ɵconstants.$$TESTABILITY, [\n              ɵconstants.$DELEGATE,\n              (testabilityDelegate: ɵangular1.ITestabilityService) => {\n                const originalWhenStable: Function = testabilityDelegate.whenStable;\n                const injector = this.injector;\n                // Cannot use arrow function below because we need the context\n                const newWhenStable = function (callback: Function) {\n                  originalWhenStable.call(testabilityDelegate, function () {\n                    const ng2Testability: Testability = injector.get(Testability);\n                    if (ng2Testability.isStable()) {\n                      callback();\n                    } else {\n                      ng2Testability.whenStable(newWhenStable.bind(testabilityDelegate, callback));\n                    }\n                  });\n                };\n\n                testabilityDelegate.whenStable = newWhenStable;\n                return testabilityDelegate;\n              },\n            ]);\n          }\n\n          if ($injector.has(ɵconstants.$INTERVAL)) {\n            $provide.decorator(ɵconstants.$INTERVAL, [\n              ɵconstants.$DELEGATE,\n              (intervalDelegate: ɵangular1.IIntervalService) => {\n                // Wrap the $interval service so that setInterval is called outside NgZone,\n                // but the callback is still invoked within it. This is so that $interval\n                // won't block stability, which preserves the behavior from AngularJS.\n                let wrappedInterval = (\n                  fn: Function,\n                  delay: number,\n                  count?: number,\n                  invokeApply?: boolean,\n                  ...pass: any[]\n                ) => {\n                  return this.ngZone.runOutsideAngular(() => {\n                    return intervalDelegate(\n                      (...args: any[]) => {\n                        // Run callback in the next VM turn - $interval calls\n                        // $rootScope.$apply, and running the callback in NgZone will\n                        // cause a '$digest already in progress' error if it's in the\n                        // same vm turn.\n                        setTimeout(() => {\n                          this.ngZone.run(() => fn(...args));\n                        });\n                      },\n                      delay,\n                      count,\n                      invokeApply,\n                      ...pass,\n                    );\n                  });\n                };\n\n                (Object.keys(intervalDelegate) as (keyof ɵangular1.IIntervalService)[]).forEach(\n                  (prop) => ((wrappedInterval as any)[prop] = intervalDelegate[prop]),\n                );\n\n                // the `flush` method will be present when ngMocks is used\n                if (intervalDelegate.hasOwnProperty('flush')) {\n                  (wrappedInterval as any)['flush'] = () => {\n                    (intervalDelegate as any)['flush']();\n                    return wrappedInterval;\n                  };\n                }\n\n                return wrappedInterval;\n              },\n            ]);\n          }\n        },\n      ])\n\n      .run([\n        ɵconstants.$INJECTOR,\n        ($injector: ɵangular1.IInjectorService) => {\n          this.$injector = $injector;\n          const $rootScope = $injector.get('$rootScope');\n\n          // Initialize the ng1 $injector provider\n          setTempInjectorRef($injector);\n          this.injector.get(ɵconstants.$INJECTOR);\n\n          // Put the injector on the DOM, so that it can be \"required\"\n          ɵangular1.element(element).data!(\n            ɵutil.controllerKey(ɵconstants.INJECTOR_KEY),\n            this.injector,\n          );\n\n          // Destroy the AngularJS app once the Angular `PlatformRef` is destroyed.\n          // This does not happen in a typical SPA scenario, but it might be useful for\n          // other use-cases where disposing of an Angular/AngularJS app is necessary\n          // (such as Hot Module Replacement (HMR)).\n          // See https://github.com/angular/angular/issues/39935.\n          this.platformRef.onDestroy(() => ɵutil.destroyApp($injector));\n\n          // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n          // We need to do this in the next tick so that we don't prevent the bootup stabilizing\n          setTimeout(() => {\n            const subscription = this.ngZone.onMicrotaskEmpty.subscribe(() => {\n              if ($rootScope.$$phase) {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                  console.warn(\n                    'A digest was triggered while one was already in progress. This may mean that something is triggering digests outside the Angular zone.',\n                  );\n                }\n\n                return $rootScope.$evalAsync();\n              }\n\n              return $rootScope.$digest();\n            });\n            $rootScope.$on('$destroy', () => {\n              subscription.unsubscribe();\n            });\n          }, 0);\n        },\n      ]);\n\n    const upgradeModule = ɵangular1.module_(\n      ɵconstants.UPGRADE_MODULE_NAME,\n      [INIT_MODULE_NAME].concat(modules),\n    );\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const windowAngular = (window as any)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the AngularJS application inside our zone\n    const returnValue = this.ngZone.run(() =>\n      ɵangular1.bootstrap(element, [upgradeModule.name], config),\n    );\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function () {\n        let args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        return ngZone.run(() => windowAngular.resumeBootstrap.apply(this, args));\n      };\n    }\n\n    return returnValue;\n  }\n}\n"],"names":["NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR","ɵconstants.UPGRADE_MODULE_NAME","ɵconstants.LAZY_MODULE_REF","ɵconstants.INJECTOR_KEY","ɵutil.isNgModuleType","ɵutil.isFunction","ɵangular1\n        .module_","ɵconstants.UPGRADE_APP_TYPE_KEY","ɵconstants.$INJECTOR","ɵutil.destroyApp","ɵconstants.$PROVIDE","ɵconstants.DOWNGRADED_MODULE_COUNT_KEY","ɵutil.getDowngradedModuleCount","ɵupgradeHelper.UpgradeHelper","ɵconstants.$SCOPE","element","ɵangular1\n            .module_","ɵconstants.$$TESTABILITY","ɵconstants.$DELEGATE","ɵconstants.$INTERVAL","ɵangular1.element","ɵutil.controllerKey","ɵangular1.module_","ɵangular1.bootstrap"],"mappings":"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"}