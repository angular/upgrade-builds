{"version":3,"sources":["../../../../../modules/@angular/upgrade/src/static/angular1_providers.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAIH,iFAAiF;AACjF,sFAAsF;AACtF,+FAA+F;AAC/F,uDAAuD;AACvD,IAAI,gBAAgB,CAAhB,eAA0B,CAAgB;AAC9C;;;GAGG;AACH,mCAJC,QAAA;IAKC,eAAe,GAJG,QAAA,CAAS;AAK7B,CAAC;AACD;;GAEG;AACH;IACE,MAAM,gBAAgB,CAPhB,QAAA,GAAqC,eAAA,CAAgB;IAQ3D,eAAe,GAPG,IAAA,CAAK,CAAC,0CAAA;IAQxB,MAAM,CAPC,QAAA,CAAS;AAQlB,CAAC;AACD;;;GAGG;AACH,iCAVC,CAAA;IAWC,MAAM,CAVC,CAAA,CAAE,GAAC,CAAG,YAAC,CAAY,CAAC;AAW7B,CAAC;AACD;;;GAGG;AACH,+BAbC,CAAA;IAcC,MAAM,CAbC,CAAA,CAAE,GAAC,CAAG,UAAC,CAAU,CAAC;AAc3B,CAAC;AACD;;;GAGG;AACH,6BAhBC,CAAA;IAiBC,MAAM,CAhBC,CAAA,CAAE,GAAC,CAAG,QAAC,CAAQ,CAAC;AAiBzB,CAAC;AAED,OAhBO,MAAA,gBAAA,CAAM,iBAAA,GAAoB;IAiB/B,yFAAyF;IACzF,2EAA2E;IAC3E,wCAAwC;IACxC,yFAAyF;IACzF,EAAC,OAhBC,EAAQ,WAAA,EAAa,UAAA,EAAY,eAAA,EAAgB;IAiBnD,EAAC,OAhBC,EAAQ,YAAA,EAAc,UAAA,EAAY,gBAAA,EAAkB,IAAA,EAAM,CAAA,WAAE,CAAW,EAAC;IAiB1E,EAAC,OAhBC,EAAQ,UAAA,EAAY,UAAA,EAAY,cAAA,EAAgB,IAAA,EAAM,CAAA,WAAE,CAAW,EAAC;IAiBtE,EAAC,OAhBC,EAAQ,QAAA,EAAU,UAAA,EAAY,YAAA,EAAc,IAAA,EAAM,CAAA,WAAE,CAAW,EAAC;CAiBnE,CAhBC","file":"angular1_providers.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as angular from '../common/angular1';\n\n// We have to do a little dance to get the ng1 injector into the module injector.\n// We store the ng1 injector so that the provider in the module injector can access it\n// Then we \"get\" the ng1 injector from the module injector, which triggers the provider to read\n// the stored injector and release the reference to it.\nlet /** @type {?} */ tempInjectorRef: angular.IInjectorService;\n/**\n * @param {?} injector\n * @return {?}\n */\nexport function setTempInjectorRef(injector: angular.IInjectorService) {\n  tempInjectorRef = injector;\n}\n/**\n * @return {?}\n */\nexport function injectorFactory() {\n  const /** @type {?} */ injector: angular.IInjectorService = tempInjectorRef;\n  tempInjectorRef = null;  // clear the value to prevent memory leaks\n  return injector;\n}\n/**\n * @param {?} i\n * @return {?}\n */\nexport function rootScopeFactory(i: angular.IInjectorService) {\n  return i.get('$rootScope');\n}\n/**\n * @param {?} i\n * @return {?}\n */\nexport function compileFactory(i: angular.IInjectorService) {\n  return i.get('$compile');\n}\n/**\n * @param {?} i\n * @return {?}\n */\nexport function parseFactory(i: angular.IInjectorService) {\n  return i.get('$parse');\n}\n\nexport const /** @type {?} */ angular1Providers = [\n  // We must use exported named functions for the ng2 factories to keep the compiler happy:\n  // > Metadata collected contains an error that will be reported at runtime:\n  // >   Function calls are not supported.\n  // >   Consider replacing the function or lambda with a reference to an exported function\n  {provide: '$injector', useFactory: injectorFactory},\n  {provide: '$rootScope', useFactory: rootScopeFactory, deps: ['$injector']},\n  {provide: '$compile', useFactory: compileFactory, deps: ['$injector']},\n  {provide: '$parse', useFactory: parseFactory, deps: ['$injector']}\n];\n"]}