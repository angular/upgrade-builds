{"version":3,"sources":["../../../../../modules/@angular/upgrade/src/static/upgrade_module.ts"],"names":[],"mappings":"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","file":"upgrade_module.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModule, NgZone, Testability} from '@angular/core/index';\n\nimport * as angular from '../common/angular1';\nimport {$$TESTABILITY, $DELEGATE, $INJECTOR, $PROVIDE, $ROOT_SCOPE, INJECTOR_KEY, UPGRADE_MODULE_NAME} from '../common/constants';\nimport {ContentProjectionHelper} from '../common/content_projection_helper';\nimport {controllerKey} from '../common/util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\n/**\n * \\@whatItDoes \n * \n * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)\n * library for hybrid upgrade apps that support AoT compilation*\n * \n * Allows AngularJS and Angular components to be used together inside a hybrid upgrade\n * application, which supports AoT compilation.\n * \n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n * 1. Creation of an Angular directive that wraps and exposes an AngularJS component so\n *    that it can be used in an Angular template. See {\\@link UpgradeComponent}.\n * 2. Creation of an AngularJS directive that wraps and exposes an Angular component so\n *    that it can be used in an AngularJS template. See {\\@link downgradeComponent}.\n * 3. Creation of an Angular root injector provider that wraps and exposes an AngularJS\n *    service so that it can be injected into an Angular context. See\n *    {\\@link UpgradeModule#upgrading-an-angular-1-service Upgrading an AngularJS service} below.\n * 4. Creation of an AngularJS service that wraps and exposes an Angular injectable\n *    so that it can be injected into an AngularJS context. See {\\@link downgradeInjectable}.\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n *    coexisting in a single application. See the\n *    {\\@link UpgradeModule#example example} below.\n * \n * ## Mental Model\n * \n * When reasoning about how a hybrid application works it is useful to have a mental model which\n * describes what is happening and explains what is happening at the lowest level.\n * \n * 1. There are two independent frameworks running in a single application, each framework treats\n *    the other as a black box.\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\n *    DOM elements and ignores others.\n * 3. AngularJS directives always execute inside the AngularJS framework codebase regardless of\n *    where they are instantiated.\n * 4. Angular components always execute inside the Angular framework codebase regardless of\n *    where they are instantiated.\n * 5. An AngularJS component can be \"upgraded\"\" to an Angular component. This is achieved by\n *    defining an Angular directive, which bootstraps the AngularJS component at its location\n *    in the DOM. See {\\@link UpgradeComponent}.\n * 6. An Angular component can be \"downgraded\"\" to an AngularJS component. This is achieved by\n *    defining an AngularJS directive, which bootstraps the Angular component at its location\n *    in the DOM. See {\\@link downgradeComponent}.\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n *    the framework doing the instantiation. The other framework then instantiates and owns the\n *    view for that component.\n *    a. This implies that the component bindings will always follow the semantics of the\n *       instantiation framework.\n *    b. The DOM attributes are parsed by the framework that owns the current template. So\n * attributes\n *       in AngularJS templates must use kebab-case, while AngularJS templates must use camelCase.\n *    c. However the template binding syntax will always use the Angular style, e.g. square\n *       brackets (`[...]`) for property binding.\n * 8. AngularJS is always bootstrapped first and owns the root component.\n * 9. The new application is running in an Angular zone, and therefore it no longer needs calls\n * to\n *    `$apply()`.\n * \n * \\@howToUse \n * \n * `import {UpgradeModule} from '\\@angular/upgrade/static';`\n * \n * ## Example\n * Import the {\\@link UpgradeModule} into your top level {\\@link NgModule Angular `NgModule`}.\n * \n * {\\@example upgrade/static/ts/module.ts region='ng2-module'}\n * \n * Then bootstrap the hybrid upgrade app's module, get hold of the {\\@link UpgradeModule} instance\n * and use it to bootstrap the top level [AngularJS\n * module](https://docs.angularjs.org/api/ng/type/angular.Module).\n * \n * {\\@example upgrade/static/ts/module.ts region='bootstrap'}\n * \n * \n * ## Upgrading an AngularJS service\n * \n * There is no specific API for upgrading an AngularJS service. Instead you should just follow the\n * following recipe:\n * \n * Let's say you have an AngularJS service:\n * \n * {\\@example upgrade/static/ts/module.ts region=\"ng1-title-case-service\"}\n * \n * Then you should define an Angular provider to be included in your {\\@link NgModule} `providers`\n * property.\n * \n * {\\@example upgrade/static/ts/module.ts region=\"upgrade-ng1-service\"}\n * \n * Then you can use the \"upgraded\" AngularJS service by injecting it into an Angular component\n * or service.\n * \n * {\\@example upgrade/static/ts/module.ts region=\"use-ng1-upgraded-service\"}\n * \n * \\@description \n * \n * This class is an `NgModule`, which you import to provide AngularJS core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n * \n * ## Core AngularJS services\n * Importing this {\\@link NgModule} will add providers for the core\n * [AngularJS services](https://docs.angularjs.org/api/ng/service) to the root injector.\n * \n * ## Bootstrap\n * The runtime instance of this class contains a {\\@link UpgradeModule#bootstrap `bootstrap()`}\n * method, which you use to bootstrap the top level AngularJS module onto an element in the\n * DOM for the hybrid upgrade app.\n * \n * It also contains properties to access the {\\@link UpgradeModule#injector root injector}, the\n * bootstrap {\\@link NgZone} and the\n * [AngularJS $injector](https://docs.angularjs.org/api/auto/service/$injector).\n * \n * \\@experimental\n */\nexport class UpgradeModule {\npublic $injector: any /*angular.IInjectorService*/;\n/**\n * @param {?} injector\n * @param {?} ngZone\n */\nconstructor(\npublic injector: Injector,\npublic ngZone: NgZone) {}\n/**\n * Bootstrap an AngularJS application from this NgModule\n * @param {?} element the element on which to bootstrap the AngularJS application\n * @param {?=} modules\n * @param {?=} config\n * @return {?}\n */\nbootstrap(\n      element: Element, modules: string[] = [], config?: any /*angular.IAngularBootstrapConfig*/) {\n    const /** @type {?} */ INIT_MODULE_NAME = UPGRADE_MODULE_NAME + '.init';\n\n    // Create an ng1 module to bootstrap\n    const /** @type {?} */ initModule =\n        angular\n            .module(INIT_MODULE_NAME, [])\n\n            .value(INJECTOR_KEY, this.injector)\n\n            .config([\n              $PROVIDE, $INJECTOR,\n              ($provide: angular.IProvideService, $injector: angular.IInjectorService) => {\n                if ($injector.has($$TESTABILITY)) {\n                  $provide.decorator($$TESTABILITY, [\n                    $DELEGATE,\n                    (testabilityDelegate: angular.ITestabilityService) => {\n                      const /** @type {?} */ originalWhenStable: Function = testabilityDelegate.whenStable;\n                      const /** @type {?} */ injector = this.injector;\n                      // Cannot use arrow function below because we need the context\n                      const /** @type {?} */ newWhenStable = function(callback: Function) {\n                        originalWhenStable.call(testabilityDelegate, function() {\n                          const /** @type {?} */ ng2Testability: Testability = injector.get(Testability);\n                          if (ng2Testability.isStable()) {\n                            callback();\n                          } else {\n                            ng2Testability.whenStable(\n                                newWhenStable.bind(testabilityDelegate, callback));\n                          }\n                        });\n                      };\n\n                      testabilityDelegate.whenStable = newWhenStable;\n                      return testabilityDelegate;\n                    }\n                  ]);\n                }\n              }\n            ])\n\n            .run([\n              $INJECTOR,\n              ($injector: angular.IInjectorService) => {\n                this.$injector = $injector;\n\n                // Initialize the ng1 $injector provider\n                setTempInjectorRef($injector);\n                this.injector.get($INJECTOR);\n\n                // Put the injector on the DOM, so that it can be \"required\"\n                angular.element(element).data(controllerKey(INJECTOR_KEY), this.injector);\n\n                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n                // We need to do this in the next tick so that we don't prevent the bootup\n                // stabilizing\n                setTimeout(() => {\n                  const /** @type {?} */ $rootScope = $injector.get('$rootScope');\n                  const /** @type {?} */ subscription =\n                      this.ngZone.onMicrotaskEmpty.subscribe(() => $rootScope.$digest());\n                  $rootScope.$on('$destroy', () => { subscription.unsubscribe(); });\n                }, 0);\n              }\n            ]);\n\n    const /** @type {?} */ upgradeModule = angular.module(UPGRADE_MODULE_NAME, [INIT_MODULE_NAME].concat(modules));\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const /** @type {?} */ windowAngular = ( /** @type {?} */((window as any)) /** TODO #???? */)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the AngularJS application inside our zone\n    this.ngZone.run(() => { angular.bootstrap(element, [upgradeModule.name], config); });\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const /** @type {?} */ originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const /** @type {?} */ ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function() {\n        let /** @type {?} */ args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        ngZone.run(() => { windowAngular.resumeBootstrap.apply(this, args); });\n      };\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{providers: [angular1Providers, ContentProjectionHelper]}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: NgZone, },\n];\n}\n\nfunction UpgradeModule_tsickle_Closure_declarations() {\n/** @type {?} */\nUpgradeModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nUpgradeModule.ctorParameters;\n/**\n * The AngularJS `$injector` for the upgrade application.\n * @type {?}\n */\nUpgradeModule.prototype.$injector;\n/**\n * The root {\\@link Injector} for the upgrade application.\n * @type {?}\n */\nUpgradeModule.prototype.injector;\n/**\n * The bootstrap zone for the upgrade application\n * @type {?}\n */\nUpgradeModule.prototype.ngZone;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}